{"version":3,"sources":["../node_modules/.pnpm/tsup@8.0.1_ts-node@10.9.2_typescript@5.3.3/node_modules/tsup/assets/cjs_shims.js","../src/cli.ts","../src/supabase-to-zod.ts","../src/lib/get-import-path.ts","../src/lib/transform-types.ts","../src/lib/get-node-name.ts"],"sourcesContent":["// Shim globals in cjs bundle\n// There's a weird bug that esbuild will always inject importMetaUrl\n// if we export it as `const importMetaUrl = ... __filename ...`\n// But using a function will not cause this issue\n\nconst getImportMetaUrl = () =>\n  typeof document === 'undefined'\n    ? new URL('file:' + __filename).href\n    : (document.currentScript && document.currentScript.src) ||\n      new URL('main.js', document.baseURI).href\n\nexport const importMetaUrl = /* @__PURE__ */ getImportMetaUrl()\n","#!/usr/bin/env node\n\nimport { program } from 'commander';\nimport fsSync from 'node:fs';\nimport { join } from 'node:path';\nimport supabaseToZod, { supabaseToZodOptionsSchema } from './supabase-to-zod';\nimport * as url from 'url';\n\nconst __dirname = url.fileURLToPath(new URL('.', import.meta.url));\nconst defaultPackageJsonPath = join(__dirname, 'package.json');\nconst packageJsonPath = fsSync.existsSync(defaultPackageJsonPath)\n  ? defaultPackageJsonPath\n  : join(__dirname, '../package.json');\n\nconst packageJson = JSON.parse(\n  fsSync.readFileSync(packageJsonPath, {}).toString()\n);\n\nprogram\n  .name(packageJson.name)\n  .version(packageJson.version)\n  .option('-i, --input <input>', 'Path to the types generated by supabase cli')\n  .option('-o, --output <output>', 'Path to the output file')\n  .option('-s, --schema [schema]', 'Specify schema', 'public')\n  .parse(process.argv);\nconst opts = supabaseToZodOptionsSchema.parse(program.opts());\nvoid (async () => {\n  try {\n    await supabaseToZod(opts);\n    process.exit();\n  } catch (error) {\n    console.error(error);\n    process.exit(1);\n  }\n})();\n","import { generate } from 'ts-to-zod';\n\nimport fs from 'node:fs/promises';\nimport { join } from 'node:path';\nimport prettier from 'prettier';\n\nimport { z } from 'zod';\nimport {\n  transformTypes,\n  getImportPath,\n  transformTypesOptionsSchema,\n} from './lib';\n\nconst simplifiedJSDocTagSchema = z.object({\n  name: z.string(),\n  value: z.string().optional(),\n});\n\nconst getSchemaNameSchema = z.function().args(z.string()).returns(z.string());\n\nconst nameFilterSchema = z.function().args(z.string()).returns(z.boolean());\n\nconst jSDocTagFilterSchema = z\n  .function()\n  .args(z.array(simplifiedJSDocTagSchema))\n  .returns(z.boolean());\n\nexport const supabaseToZodOptionsSchema = transformTypesOptionsSchema\n  .omit({ sourceText: true })\n  .extend({\n    input: z.string(),\n    output: z.string(),\n    skipValidation: z.boolean().optional(),\n    maxRun: z.number().optional(),\n    nameFilter: nameFilterSchema.optional(),\n    jsDocTagFilter: jSDocTagFilterSchema.optional(),\n    getSchemaName: getSchemaNameSchema.optional(),\n    keepComments: z.boolean().optional().default(false),\n    skipParseJSDoc: z.boolean().optional().default(false),\n  });\n\nexport type SupabaseToZodOptions = z.infer<typeof supabaseToZodOptionsSchema>;\n\nexport default async function supabaseToZod(opts: SupabaseToZodOptions) {\n  const inputPath = join(process.cwd(), opts.input);\n  const outputPath = join(process.cwd(), opts.output);\n\n  const sourceText = await fs.readFile(inputPath, 'utf-8');\n\n  const parsedTypes = transformTypes({ sourceText, ...opts });\n\n  const { getZodSchemasFile } = generate({\n    sourceText: parsedTypes,\n    ...opts,\n  });\n\n  const zodSchemasFile = getZodSchemasFile(\n    getImportPath(outputPath, inputPath)\n  );\n\n  const prettierConfig = await prettier.resolveConfig(process.cwd());\n\n  await fs.writeFile(\n    outputPath,\n    await prettier.format(zodSchemasFile, {\n      parser: 'babel-ts',\n      ...prettierConfig,\n    })\n  );\n}\n","import slash from 'slash';\nimport { parse, relative } from 'path';\n\n/**\n * Resolve the path of an import.\n *\n * @param from path of the current file\n * @param to path of the import file\n * @returns relative path without extension\n */\nexport function getImportPath(from: string, to: string) {\n  const relativePath = slash(relative(from, to).slice(1));\n  const { dir, name } = parse(relativePath);\n\n  return `${dir}/${name}`;\n}\n","import ts from 'typescript';\nimport { z } from 'zod';\nimport { getNodeName } from './get-node-name';\n\nconst enumFormatterSchema = z.function().args(z.string()).returns(z.string());\n\nconst functionFormatterSchema = z\n  .function()\n  .args(z.string(), z.string())\n  .returns(z.string());\n\nconst tableOrViewFormatterSchema = z\n  .function()\n  .args(z.string(), z.string())\n  .returns(z.string());\n\nexport const transformTypesOptionsSchema = z.object({\n  sourceText: z.string(),\n  schema: z.string().default('public'),\n  enumFormatter: enumFormatterSchema.default(() => (name: string) => name),\n  functionFormatter: functionFormatterSchema.default(\n    () => (name: string, type: string) => `${name}${type}`\n  ),\n  tableOrViewFormatter: tableOrViewFormatterSchema.default(\n    () => (name: string, operation: string) => `${name}${operation}`\n  ),\n});\n\nexport type TransformTypesOptions = z.infer<typeof transformTypesOptionsSchema>;\n\nexport const transformTypes = z\n  .function()\n  .args(transformTypesOptionsSchema)\n  .returns(z.string())\n  .implement((opts) => {\n    const { schema, tableOrViewFormatter, enumFormatter, functionFormatter } =\n      opts;\n    const sourceFile = ts.createSourceFile(\n      'index.ts',\n      opts.sourceText,\n      ts.ScriptTarget.Latest\n    );\n\n    const typeStrings: string[] = [];\n    const enumNames: { name: string; formattedName: string }[] = [];\n\n    sourceFile.forEachChild((n) => {\n      const processDatabase = (n: ts.Node | ts.TypeNode) => {\n        if (ts.isPropertySignature(n)) {\n          // Schema\n          const schemaName = getNodeName(n);\n          if (schemaName === schema) {\n            n.forEachChild((n) => {\n              if (ts.isTypeLiteralNode(n)) {\n                n.forEachChild((n) => {\n                  if (ts.isPropertySignature(n) && ts.isIdentifier(n.name)) {\n                    if (['Tables', 'Views'].includes(n.name.text)) {\n                      n.forEachChild((n) => {\n                        if (ts.isTypeLiteralNode(n)) {\n                          n.forEachChild((n) => {\n                            if (ts.isPropertySignature(n)) {\n                              // Table or View\n                              const tableOrViewName = getNodeName(n);\n                              n.forEachChild((n) => {\n                                if (ts.isTypeLiteralNode(n)) {\n                                  n.forEachChild((n) => {\n                                    if (ts.isPropertySignature(n)) {\n                                      const operation = getNodeName(n);\n                                      if (operation) {\n                                        n.forEachChild((n) => {\n                                          if (ts.isTypeLiteralNode(n)) {\n                                            typeStrings.push(\n                                              `export type ${tableOrViewFormatter(\n                                                tableOrViewName,\n                                                operation,\n                                              )} = ${n.getText(sourceFile)}`,\n                                            );\n                                          }\n                                        });\n                                      }\n                                    }\n                                  });\n                                }\n                              });\n                            }\n                          });\n                        }\n                      });\n                    }\n                    if ('Enums' === n.name.text) {\n                      n.forEachChild((n) => {\n                        if (ts.isTypeLiteralNode(n)) {\n                          n.forEachChild((n) => {\n                            const enumName = getNodeName(n);\n                            if (ts.isPropertySignature(n)) {\n                              n.forEachChild((n) => {\n                                if (ts.isUnionTypeNode(n)) {\n                                  const formattedName = enumFormatter(enumName);\n                                  typeStrings.push(\n                                    `export type ${formattedName} = ${n.getText(\n                                      sourceFile,\n                                    )}`,\n                                  );\n                                  enumNames.push({\n                                    formattedName,\n                                    name: enumName,\n                                  });\n                                }\n                              });\n                            }\n                          });\n                        }\n                      });\n                    }\n                    if ('Functions' === n.name.text) {\n                      n.forEachChild((n) => {\n                        if (ts.isTypeLiteralNode(n)) {\n                          n.forEachChild((n) => {\n                            if (ts.isPropertySignature(n)) {\n                              const functionName = getNodeName(n);\n                              n.forEachChild((n) => {\n                                if (ts.isTypeLiteralNode(n)) {\n                                  n.forEachChild((n) => {\n                                    if (ts.isPropertySignature(n)) {\n                                      const argType = getNodeName(n);\n                                      n.forEachChild((n) => {\n                                        if (ts.isTypeReferenceNode(n)) {\n                                          typeStrings.push(\n                                            `export type ${functionFormatter(\n                                              functionName,\n                                              argType,\n                                            )} = ${n.getText(sourceFile)}`,\n                                          );\n                                        }\n                                      });\n                                    }\n                                  });\n                                }\n                              });\n                            }\n                          });\n                        }\n                      });\n                    }\n                  }\n                });\n              }\n            });\n          }\n        }\n      };\n\n      // Database\n      if (\n        ts.isTypeAliasDeclaration(n) &&\n        ts.isTypeLiteralNode(n.type) &&\n        n.name.text === 'Database'\n      ) {\n        n.type.members.forEach(processDatabase);\n      } else if (ts.isInterfaceDeclaration(n) && n.name.text === 'Database') {\n        n.forEachChild(processDatabase);\n      }\n\n      if (ts.isTypeAliasDeclaration(n) && n.name.text === 'Json') {\n        typeStrings.push(n.getText(sourceFile));\n      }\n    });\n\n    let parsedTypes = typeStrings\n      .filter((s) => !s.includes('Record<number'))\n      .join(';\\n');\n\n    for (const { name, formattedName } of enumNames) {\n      parsedTypes = parsedTypes.replaceAll(\n        `Database[\"${schema}\"][\"Enums\"][\"${name}\"]`,\n        formattedName\n      );\n      parsedTypes = parsedTypes.replaceAll(\n        `Database['${schema}']['Enums']['${name}']`,\n        formattedName\n      );\n    }\n\n    return parsedTypes;\n  });\n","import ts from 'typescript';\n\nexport const getNodeName = (n: ts.Node) => {\n  let name: string | undefined;\n  n.forEachChild((n) => {\n    if (ts.isIdentifier(n)) {\n      name = n.text;\n    }\n  });\n  if (!name) throw new Error('Cannot get name of node');\n  return name;\n};\n"],"mappings":"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","names":["import_node_path","import_zod","slash","import_typescript","n","ts","opts","ts","n","opts","fs","prettier","fsSync"]}