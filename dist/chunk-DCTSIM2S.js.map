{"version":3,"sources":["../src/lib/transform-types.ts","../src/lib/get-node-name.ts","../src/lib/get-import-path.ts","../src/supabase-to-zod.ts"],"sourcesContent":["import ts from 'typescript';\nimport { z } from 'zod';\nimport { getNodeName } from './get-node-name';\n\nconst enumFormatterSchema = z.function().args(z.string()).returns(z.string());\n\nconst functionFormatterSchema = z\n  .function()\n  .args(z.string(), z.string())\n  .returns(z.string());\n\nconst tableOrViewFormatterSchema = z\n  .function()\n  .args(z.string(), z.string())\n  .returns(z.string());\n\nexport const transformTypesOptionsSchema = z.object({\n  sourceText: z.string(),\n  schema: z.string().default('public'),\n  enumFormatter: enumFormatterSchema.default(() => (name: string) => name),\n  functionFormatter: functionFormatterSchema.default(\n    () => (name: string, type: string) => `${name}${type}`\n  ),\n  tableOrViewFormatter: tableOrViewFormatterSchema.default(\n    () => (name: string, operation: string) => `${name}${operation}`\n  ),\n});\n\nexport type TransformTypesOptions = z.infer<typeof transformTypesOptionsSchema>;\n\nexport const transformTypes = z\n  .function()\n  .args(transformTypesOptionsSchema)\n  .returns(z.string())\n  .implement((opts) => {\n    const { schema, tableOrViewFormatter, enumFormatter, functionFormatter } =\n      opts;\n    const sourceFile = ts.createSourceFile(\n      'index.ts',\n      opts.sourceText,\n      ts.ScriptTarget.Latest\n    );\n\n    const typeStrings: string[] = [];\n    const enumNames: { name: string; formattedName: string }[] = [];\n\n    sourceFile.forEachChild((n) => {\n      const processDatabase = (n: ts.Node | ts.TypeNode) => {\n        if (ts.isPropertySignature(n)) {\n          // Schema\n          const schemaName = getNodeName(n);\n          if (schemaName === schema) {\n            n.forEachChild((n) => {\n              if (ts.isTypeLiteralNode(n)) {\n                n.forEachChild((n) => {\n                  if (ts.isPropertySignature(n) && ts.isIdentifier(n.name)) {\n                    if (['Tables', 'Views'].includes(n.name.text)) {\n                      n.forEachChild((n) => {\n                        if (ts.isTypeLiteralNode(n)) {\n                          n.forEachChild((n) => {\n                            if (ts.isPropertySignature(n)) {\n                              // Table or View\n                              const tableOrViewName = getNodeName(n);\n                              n.forEachChild((n) => {\n                                if (ts.isTypeLiteralNode(n)) {\n                                  n.forEachChild((n) => {\n                                    if (ts.isPropertySignature(n)) {\n                                      const operation = getNodeName(n);\n                                      if (operation) {\n                                        n.forEachChild((n) => {\n                                          if (ts.isTypeLiteralNode(n)) {\n                                            typeStrings.push(\n                                              `export type ${tableOrViewFormatter(\n                                                tableOrViewName,\n                                                operation,\n                                              )} = ${n.getText(sourceFile)}`,\n                                            );\n                                          }\n                                        });\n                                      }\n                                    }\n                                  });\n                                }\n                              });\n                            }\n                          });\n                        }\n                      });\n                    }\n                    if ('Enums' === n.name.text) {\n                      n.forEachChild((n) => {\n                        if (ts.isTypeLiteralNode(n)) {\n                          n.forEachChild((n) => {\n                            const enumName = getNodeName(n);\n                            if (ts.isPropertySignature(n)) {\n                              n.forEachChild((n) => {\n                                if (ts.isUnionTypeNode(n)) {\n                                  const formattedName = enumFormatter(enumName);\n                                  typeStrings.push(\n                                    `export type ${formattedName} = ${n.getText(\n                                      sourceFile,\n                                    )}`,\n                                  );\n                                  enumNames.push({\n                                    formattedName,\n                                    name: enumName,\n                                  });\n                                }\n                              });\n                            }\n                          });\n                        }\n                      });\n                    }\n                    if ('Functions' === n.name.text) {\n                      n.forEachChild((n) => {\n                        if (ts.isTypeLiteralNode(n)) {\n                          n.forEachChild((n) => {\n                            if (ts.isPropertySignature(n)) {\n                              const functionName = getNodeName(n);\n                              n.forEachChild((n) => {\n                                if (ts.isTypeLiteralNode(n)) {\n                                  n.forEachChild((n) => {\n                                    if (ts.isPropertySignature(n)) {\n                                      const argType = getNodeName(n);\n                                      n.forEachChild((n) => {\n                                        if (ts.isTypeReferenceNode(n)) {\n                                          typeStrings.push(\n                                            `export type ${functionFormatter(\n                                              functionName,\n                                              argType,\n                                            )} = ${n.getText(sourceFile)}`,\n                                          );\n                                        }\n                                      });\n                                    }\n                                  });\n                                }\n                              });\n                            }\n                          });\n                        }\n                      });\n                    }\n                  }\n                });\n              }\n            });\n          }\n        }\n      };\n\n      // Database\n      if (\n        ts.isTypeAliasDeclaration(n) &&\n        ts.isTypeLiteralNode(n.type) &&\n        n.name.text === 'Database'\n      ) {\n        n.type.members.forEach(processDatabase);\n      } else if (ts.isInterfaceDeclaration(n) && n.name.text === 'Database') {\n        n.forEachChild(processDatabase);\n      }\n\n      if (ts.isTypeAliasDeclaration(n) && n.name.text === 'Json') {\n        typeStrings.push(n.getText(sourceFile));\n      }\n    });\n\n    let parsedTypes = typeStrings\n      .filter((s) => !s.includes('Record<number'))\n      .join(';\\n');\n\n    for (const { name, formattedName } of enumNames) {\n      parsedTypes = parsedTypes.replaceAll(\n        `Database[\"${schema}\"][\"Enums\"][\"${name}\"]`,\n        formattedName\n      );\n      parsedTypes = parsedTypes.replaceAll(\n        `Database['${schema}']['Enums']['${name}']`,\n        formattedName\n      );\n    }\n\n    return parsedTypes;\n  });\n","import ts from 'typescript';\n\nexport const getNodeName = (n: ts.Node) => {\n  let name: string | undefined;\n  n.forEachChild((n) => {\n    if (ts.isIdentifier(n)) {\n      name = n.text;\n    }\n  });\n  if (!name) throw new Error('Cannot get name of node');\n  return name;\n};\n","import slash from 'slash';\nimport { parse, relative } from 'path';\n\n/**\n * Resolve the path of an import.\n *\n * @param from path of the current file\n * @param to path of the import file\n * @returns relative path without extension\n */\nexport function getImportPath(from: string, to: string) {\n  const relativePath = slash(relative(from, to).slice(1));\n  const { dir, name } = parse(relativePath);\n\n  return `${dir}/${name}`;\n}\n","import { generate } from 'ts-to-zod';\n\nimport fs from 'node:fs/promises';\nimport { join } from 'node:path';\nimport prettier from 'prettier';\n\nimport { z } from 'zod';\nimport {\n  transformTypes,\n  getImportPath,\n  transformTypesOptionsSchema,\n} from './lib';\n\nconst simplifiedJSDocTagSchema = z.object({\n  name: z.string(),\n  value: z.string().optional(),\n});\n\nconst getSchemaNameSchema = z.function().args(z.string()).returns(z.string());\n\nconst nameFilterSchema = z.function().args(z.string()).returns(z.boolean());\n\nconst jSDocTagFilterSchema = z\n  .function()\n  .args(z.array(simplifiedJSDocTagSchema))\n  .returns(z.boolean());\n\nexport const supabaseToZodOptionsSchema = transformTypesOptionsSchema\n  .omit({ sourceText: true })\n  .extend({\n    input: z.string(),\n    output: z.string(),\n    skipValidation: z.boolean().optional(),\n    maxRun: z.number().optional(),\n    nameFilter: nameFilterSchema.optional(),\n    jsDocTagFilter: jSDocTagFilterSchema.optional(),\n    getSchemaName: getSchemaNameSchema.optional(),\n    keepComments: z.boolean().optional().default(false),\n    skipParseJSDoc: z.boolean().optional().default(false),\n  });\n\nexport type SupabaseToZodOptions = z.infer<typeof supabaseToZodOptionsSchema>;\n\nexport default async function supabaseToZod(opts: SupabaseToZodOptions) {\n  const inputPath = join(process.cwd(), opts.input);\n  const outputPath = join(process.cwd(), opts.output);\n\n  const sourceText = await fs.readFile(inputPath, 'utf-8');\n\n  const parsedTypes = transformTypes({ sourceText, ...opts });\n\n  const { getZodSchemasFile } = generate({\n    sourceText: parsedTypes,\n    ...opts,\n  });\n\n  const zodSchemasFile = getZodSchemasFile(\n    getImportPath(outputPath, inputPath)\n  );\n\n  const prettierConfig = await prettier.resolveConfig(process.cwd());\n\n  await fs.writeFile(\n    outputPath,\n    await prettier.format(zodSchemasFile, {\n      parser: 'babel-ts',\n      ...prettierConfig,\n    })\n  );\n}\n"],"mappings":"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","names":["ts","n","ts","n","z","z"]}